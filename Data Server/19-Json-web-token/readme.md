##  Node JS JWT Authentication ( jsonwebtoken)
JSON Web Tokens are an open, industry standard [**RFC 7519**](https://tools.ietf.org/html/rfc7519) method for representing claims securely between two parties. [JWT.IO](https://jwt.io/) allows you to decode, verify and generate JWT.
JWT is a type of token-based authentication. The client sends the token along with every request from to the server, the server validates it and sends back the response.

![enter image description here](https://thejlmedia.com/wp-content/uploads/2018/02/jwt_05.jpg)



### Install 
``` javascript 
    npm install jsonwebtoken
```
## The JWT format
Let’s say we have a user called `user1`, and they try to log into an application or website. Once successful they would receive a token that looks like this:
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ.2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54

```
This is a JWT, and consists of three parts (separated by  `.`):

1.  The first part is the header (`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`). The header specifies information like the algorithm used to generate the signature (the third part). This part is pretty standard and is the same for any JWT using the same algorithm.
2.  The second part is the payload (`eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ`), which contains application specific information (in our case, this is the username), along with information about the expiry and validity of the token.
3.  The third part is the signature (`2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54`). It is generated by combining and hashing the first two parts along with a secret key.

Now the interesting thing is that the header and payload are not encrypted. They are just base64 encoded. This means that anyone can view their contents by decoding them.

For example, we can use this  [online tool](https://tools.sohamkamani.com/base64-decoder/)  and decode the header or payload.

Which will show its contents as:
```json
{"alg":"HS256","typ":"JWT"}
```
f you are using linux or Mac OS, you can also execute the following statement on the terminal:

```text
echo eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 | base64 -d
```
Similarly, the contents of the payload are:
```json
{"username":"user1","exp":1547974082}
```

### How the JWT signature works

So if the header and signature of a JWT can be read and written to by anyone, what  _actually_  makes a JWT secure? The answer lies in how the last part (the signature) is generated.

Let’s pretend you’re and application that wants to issue a JWT to a user (for example,  `user1`) that has successfully signed in.

Making the header and payload are pretty straightforward: The header is more or less fixed, and the payload JSON object is formed by setting the user ID and the expiry time in unix milliseconds.

The application issuing the token will also have a key, which is a secret value, and known only to the application itself. The base64 representations of the header and payload are then combined with the secret key and then passed through a hashing algorithm (in this case its  `HS256`, as mentioned in the header)

![jwt algorithm](https://www.sohamkamani.com/1c2963a562418d9fccfa9c6667da826c/jwt-algo.svg)

### Verifying a JWT

In order to verify an incoming JWT, a signature is once again generated using the header and payload from the incoming JWT, and the secret key. If the signature matches the one on the JWT, then the JWT is considered valid.

Now let’s pretend that you’re a hacker trying to issue a fake token. You can easily generate the header and payload, but without knowing the key, there is no way to generate a valid signature. If you try to tamper with the existing payload of a valid JWT, the signatures will no longer match.

![jwt verification](https://www.sohamkamani.com/2852602f7e716b336d770a69ea56a22d/jwt-verification.svg)

In this way, the JWT acts as a way to authorize users in a secure manner, without actually storing any information (besides the key) on the application server.